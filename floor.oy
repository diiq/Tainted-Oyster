join ← cons
first ← car
rest ← cdr

quoted ← '((... 'args) args)

list ← '((... args) args)

unary-λ ← quoted:
    ('args)
    oif (atom args):
        args ← list args
    quoted:
        (... 'code)
        set-bindings args (bindings code)    
        list args @code
           

unary-\ ← unary-λ

do ← λ(... 'code):
    ((λ(): *code))

eval ← λ(code):
    do: really code

unary-, ← eval

then ← do
else ← do
if ← oif

not ← λx: if x () 't
unary-! ← not

and ← λ(... 'xs):
    if !xs:
        't
        if ,(car xs):
            and *(rest xs)

# Will fail if () gets a .first!
first ← λx:
    if x.first:
        x.first x
        if (x.type).first: 
            (x.type).first x
            if !(atom x):
                car x
                signal: list 'no-way-to-first x

rest ← λx:
    if x.rest:
        x.rest x
        if (x.type <<and>> x.type.rest):
            x.type.rest x
            if !(atom x):
                cdr x
                signal: list 'no-way-to-rest x


map1 ← λ(f list):
    if list:
        f (first list) :: map1 f: rest list


fold ← λ(f list start):
    if !list:
        start
        fold f: 
            rest list 
            f (first list) start
 
map ← λ(f ... lists):
    if (and @lists): 
        f @(map1 first lists) :: map f @(map1 rest lists)
        
foreach ← λ('member alist ... 'code):
    map: 
        λ(really member): *code
        alist

while ← λ('test ... 'code):
    if ,test: 
        then:
            map eval code
            while (really test) *code

set! ← set

set ← λ('thing value):
    if (not: atom thing):
        then:
            call ← ,(first thing)
            if call.set: 
                call.set *(rest thing) value
                signal: list 'no-known-setter-for thing
        else:
            leak (really thing)
            set! (really thing) value

second ← λx: first: rest x

find-if ← λ(f xs):
    if xs:
        if (f: first xs):
            first xs
            find-if: rest xs


class ← λ('name 'inheritance ... 'members):
    leak: really name
    init ← find-if (λx: first x <<is>> 'init) members
    init-args ← if init (second init) ()

    it ← really name ← λ(really init-args):
        self ← '(really name)
        it.subclass self
        if init: self.init *(leak-all: init-args)
        self

    it.subclass ← λself:
        map (λ(,class): class.subclass self) inheritance
        map:
            λm: set self.(really: first m): 
                leak: 
                    self
                    λ(really: second m): *(rest: rest m)
                    self
            members
        self
         

table-set:
    set
    info-table table-get
    table-set


#-------------------------------------------------------------#
# Playground

#foreach q '(a b c d e f):
#     print q

# print 'this 'far

a ← '(a b c d e)
while a: 
    a ← cdr a
#map print '(a b c d e)
# print: if () () 't

# print: if 't 't ()

# if ():
#     then:
#         print 'hello
#     else:
#         print 'there


# baby ← 'foo
# print baby.fee
# baby.fee ← 'one-hundred-dollars
# print baby.fee


# make-account ← λbalance:
#     account ← 'account
#     account.type ← 'account

#     account.withdraw ← λamount:
#         if (not balance):
#             then:
#                 'Insufficient-funds
#             else:
#                 balance ← amount

#     account.deposit ← λ():
#         balance
    
#     balance ← 'amount
#     account

# acc ← make-account 'loo
# print (acc.deposit)
# acc.withdraw 'poo
# print (acc.deposit)
# acc.withdraw ()

# print: quoted final answer


# binding-of ← λ('symbol obj):
#     table-get symbol (bindings obj)
# #can compose pull this stunt for me?
# binding-of.set ← λ('symbol obj value):
#     (table-get symbol (bindings obj)) ← value


class account ():
    withdraw amount:
        if self.balance:
            self.balance ← amount
            'insufficient-funds
            
    deposit amount:
        self.balance

class maccount (account):
    fee afee:
        self.balance ← afee

    sin ():
        print 'SINNER

macc ← maccount 'afee

print 'EXISTS
print 'macc macc
print: macc.fee 'peope

print 'deposit: macc.deposit ()
print: macc.withdraw 'pop 
print:  macc.deposit 'p
macc.withdraw ()
print (macc.deposit 't)
print: macc.withdraw 'poo


# foo ← '(t a b o)
# print: first foo
# foo.first ← λx: 'poop
# print: first foo
