quoted ← '((... 'args) args)

list ← '((... args) args)

unary-λ ← quoted:
    ('args)
    oif (atom args):
        args ← list args
    quoted:
        (... 'code)
        set-bindings args (bindings code)    
        list args @code
           

unary-\ ← unary-λ

do ← λ(... 'code):
    ((λ(): *code))

eval ← λ(code):
    do: really code

unary-, ← eval

then ← do
else ← do
if ← oif

not ← λx: if x () 't
unary-! ← not

and ← λ(... 'xs):
    if !xs:
        't
        if ,(car xs):
            and *(cdr xs)

# These will look better with cons.
first ← λx:
    if x.first:
        x.first x
        if (x.type <<and>> x.type.first):
            x.type.first x
            if !(atom x):
                car x
                signal: list 'no-way-to-first x

rest ← λx:
    if x.rest:
        x.rest x
        if (x.type <<and>> x.type.rest):
            x.type.rest x
            if !(atom x):
                cdr x
                signal: list 'no-way-to-rest x

map1 ← λ(f list):
    if list:
        f (car list) :: map1 f: cdr list


fold ← λ(f list start):
    if !list start:
        fold f: 
            cdr list 
            f (car list) start
 
map ← λ(f ... lists):
    if (and @lists): 
        f @(map1 car lists) :: map f @(map1 cdr lists)
        
foreach ← λ('member alist ... 'code):
    map: 
        λ(really member): *code
        alist

while ← λ('test ... 'code):
    if ,test: 
        then:
            map eval code
            while (really test) *code

set! ← set

set ← λ('thing value):
    if (not: atom thing):
        then:
            call ← ,(car thing)
            if call.set: 
                call.set *(cdr thing) value
                signal: list 'no-known-setter-for thing
        else:
            leak (really thing)
            set! (really thing) value

class ← λ('name 'init ... 'members):
    leak: really name
    really name ← λ(really: car: cdr init):
        self ← '(really name)
        members ← init :: members 
        map:
            λm: set self.(really: car m): 
                leak: 
                    self
                    λ(really: car: cdr m): *(cdr: cdr m)
                    self
            members
        self.init *(leak-all: car: cdr init)
        self

table-set:
    set
    info-table table-get
    table-set

#-------------------------------------------------------------#
# Playground

#foreach q '(a b c d e f):
#     print q

# print 'this 'far

a ← '(a b c d e)
while a: 
    a ← cdr a

#map print '(a b c d e)
# print: if () () 't

# print: if 't 't ()

# if ():
#     then:
#         print 'hello
#     else:
#         print 'there


# baby ← 'foo
# print baby.fee
# baby.fee ← 'one-hundred-dollars
# print baby.fee


# make-account ← λbalance:
#     account ← 'account
#     account.type ← 'account

#     account.withdraw ← λamount:
#         if (not balance):
#             then:
#                 'Insufficient-funds
#             else:
#                 balance ← amount

#     account.deposit ← λ():
#         balance
    
#     balance ← 'amount
#     account

# acc ← make-account 'loo
# print (acc.deposit)
# acc.withdraw 'poo
# print (acc.deposit)
# acc.withdraw ()

# print: quoted final answer


# binding-of ← λ('symbol obj):
#     table-get symbol (bindings obj)
# #can compose pull this stunt for me?
# binding-of.set ← λ('symbol obj value):
#     (table-get symbol (bindings obj)) ← value



# class maccount:
#     init balance:
#         self.balance ← balance

#     withdraw amount:
#         if self.balance:
#             self.balance ← amount
#             'insufficient-funds
            
#     deposit amount:
#         self.balance

# macc ← maccount 'see

# print 'macc macc
# print 'deposit: macc.deposit ()
# print: macc.withdraw 'pop 
# print:  macc.deposit 'p
# macc.withdraw ()
# print (macc.deposit 't)
# print: macc.withdraw 'poo


foo ← '(t a b o)
print: first foo
foo.first ← λx: 'poop
print: first foo
