join ← cons
first ← car
rest ← cdr

quoted ← '((... 'args) args)

list ← '((... args) args)

unary-λ ← quoted:
    ('args)
    oif (atom args):
        args ← list args
    quoted:
        (... 'code)
        assign-bindings args (bindings code)    
        list args @code
           
unary-\ ← unary-λ

def ← λ('name 'args ... 'code):
    leak: really name
    really name ← λ(really args): *code

def do (... 'code):
    ((λ(): *code))

def eval (code):
    do: really code

unary-, ← eval


then ← do
else ← do
if ← oif

def not x: if x () 't
unary-! ← not

def and (... 'xs):
    if !xs:
        't
        if ,(car xs):
            and *(cdr xs)

def first x:
    if x.first:
        x.first x
        if (x.type && (clear x.type).first): 
            (clear x.type).first x
            if !(atom x):
                car x
                signal: list 'no-way-to-first x

def rest x:
    if x.rest:
        x.rest x
        if (x.type && (clear x.type).first):
            x.type.rest x
            if !(atom x):
                cdr x
                signal: list 'no-way-to-rest x


def map1 (f list):
    if list:
        f (first list) :: map1 f: rest list

# This will go away when strings are complete.
def string-map1 (f string):
    if string:
        f (string-first string) :: string-map1 f: string-rest string

def fold (f list start):
    if !list:
        start
        fold f: 
            rest list 
            f (first list) start
 
def map (f ... lists):
    if (and @lists): 
        f @(map1 first lists) :: map f @(map1 rest lists)
        
def while ('test ... 'code):
    if ,test: 
        then:
            map eval code
            while (really test) *code

assign! ← assign

def assign ('thing value):
    if (not: atom thing):
        then:
            call ← ,(first thing)
            if call.assign: 
                call.assign *(rest thing) value
                signal: list 'no-known-assignter-for thing
        else:
            leak (really thing)
            assign! (really thing) value

table-assign:
    assign
    info-table table-get
    table-assign

def second x: first: rest x

def find-if (f xs):
    if xs:
        if (f: first xs):
            first xs
            find-if: rest xs

def member (x xs):
    find-if (λm: m == x) xs

def cond (... 'cases):
    if cases:
        then:
            case ← first cases
            if ,(first case): 
                then: 
                    do: *(rest case)
                else: cond *(rest cases)

unary-- ← λx: 0 - x

def or (test ... 'xs):
    if test:
        test
        or *xs

def make-file-er file:
    ret ← list (file-get-char file) file
    ret.first ← λx:
        assign-cdr x: make-file-er: car: cdr x
        x.first ← ()
        x.rest ← ()
        car x
    ret.rest ← λx:
        assign-cdr x: make-file-er: car: cdr x
        x.first ← ()
        x.rest ← ()
        cdr x
    ret
    
def open filename:
    make-file-er: file-open filename
    
def reverse xs:
    def in (xs accum):
        if xs:
            in (rest xs) (first xs :: accum) 
            accum
    in xs ()

def assoc (name list):
    cond:
        !list: ()

        ((first: first list) == name):
            second: first list

        't: assoc name: rest list

def acons (name value alist):
    list name value :: alist

#--------- Real parser ----------

def make-parse-state (recursion-list stack):
    ret ← new 'foo
    ret.stack ← stack
    ret.recursion-list ← recursion-list
    ret

def stack-of (state):
    second state.stack

def parse-success (value stream):
    ret ← new 'parsed-success
    ret.stream ← stream
    ret.value ← value 
    ret

def thing-match thing:
    λ(stream state):
        if (first stream == thing):
            then:
                print "MATCHED!"
                parse-success thing (rest stream)

def and-match (... 'parsers):
    λ(stream state):
        success-stream ← stream
        def attempt (parser):
            rec ← apply-rule parser success-stream state
            if rec:
                then: 
                    success-stream ← rec.stream 
                    rec.value
                signal 'fail
        with-signal-handler:
            λx: 
                if (first x == 'fail): 
                    ()
                    unhandle-signal x
            parse-success: 
                map attempt parsers
                success-stream

def or-match (... 'parsers):
    λ(stream state):
        def attempt (parser):
            rec ← apply-rule parser stream state
            if rec: signal rec
        with-signal-handler:
            λx: if (first x == 'parsed-success): 
                first x
                unhandle-signal x
            map attempt parsers
            ()

def many-match ('parser):
    λ(stream state):
        ret ← ()
        cur ← ()
        #print "many match stack:" state.stack
        while (cur ← apply-rule parser stream state):
            #print "many match stack:" state.stack
            stream ← cur.stream
            ret ← cur.value :: ret
        parse-success: 
            reverse ret
            stream

def anything (stream state):
    parse-success:
        first stream
        rest stream

def not-match ('parser):
    λ(stream state):
        if (apply-rule parser stream state):
            ()
            anything stream
    
def list-match ('parser):
    λ(stream state):
        apply-rule parser (first stream) state

def string-match (string):
    and-match:
        *(string-map1 thing-match string)

def apply-rule (rule stream state):
    head ← if state.recursion-list: first state.recursion-list
    cond:
        !stream:
            ()

        # if the rule is the recursion-head,
        (and head (first head == rule) (second head == stream)):
            val ← stream.(really rule)
            stream.(really rule)

        # if the rule is in the recursion-list, apply the rule no matter what 
        (assoc rule state.recursion-list == stream):
            ret ← ,rule stream: make-parse-state:
                state.recursion-list
                acons rule stream: state.stack
            if (stream.(really rule) && !ret):
                stream.(really rule)
                ret

        # if the rule is the recusion-head encountered for the first time,
        # do some stuff.
        (stream.(really rule) == 'still-active):
            ret ← new 'recursed
            ret.recursion-list ← state.stack
            stream.(really rule) ← ret
            ()

        # Otherwise, if there's a memoized answer, return that.
        stream.(really rule):
            stream.(really rule)

        # If nothing else, apply the rule and memoize...
        't:
            stream.(really rule) ← 'still-active
            ret ← ,rule stream: make-parse-state:
                state.recursion-list
                acons rule stream: state.stack

            didrec ← stream.(really rule)
            
            stream.(really rule) ← ret
            #then check for recursion.
            if (didrec == 'recursed):
                then:
                    prev ← ()
                    pvalue ← ()
                    while !(pvalue == ret.stream):
                        stream.(really rule) ← ret
                        prev ← parse-success ret.value ret.stream
                        pvalue ← prev.stream
                        ret ← ,rule stream: make-parse-state:
                            acons rule stream didrec.recursion-list
                            acons rule stream state.stack
                        
            ret

def parse ('rule file):
    ret ← apply-rule rule file: make-parse-state () ()
    ret.value

aspace ← thing-match \# 
comment ← and-match:
    string-match "/*"
    not-match: string-match "*/"
    string-match "*/"

file ← open "parse-test"
print: parse comment file

#lots-of-abs ← or-match:
#    and-match:
#        lots-of-abs
#        thing-match \#b
#    thing-match \#a

#parsed ← apply-rule 'lots-of-abs (list \#a \#b \#b \#a \#b \#c): make-parse-state () ()
#print parsed.value


