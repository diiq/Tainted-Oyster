join ← cons
first ← car
rest ← cdr

quoted ← '((... 'args) args)

list ← '((... args) args)

unary-λ ← quoted:
    ('args)
    oif (atom args):
        args ← list args
    quoted:
        (... 'code)
        assign-bindings args (bindings code)    
        list args @code
           
unary-\ ← unary-λ

def ← λ('name 'args ... 'code):
    leak: really name
    really name ← λ(really args): *code

do ← λ(... 'code):
    ((λ(): *code))

eval ← λ(code):
    do: really code

unary-, ← eval

then ← do
else ← do
if ← oif

not ← λx: if x () 't
unary-! ← not

or ← λ(test ... 'xs):
    oif test:
        test
        oif xs: or *xs

is_old ← is
is ← λ(a b):
    or:
        a <<is_old>> b
        a <<binary-number-=>> b
 
and ← λ(... 'xs):
    if !xs:
        't
        if ,(car xs):
            and *(cdr xs)

first ← λx:
    if x.first:
        x.first x
        if (x.type && (clear x.type).first): 
            (x.type).first x
            if !(atom x):
                car x
                signal: list 'no-way-to-first x

rest ← λx:
    if x.rest:
        x.rest x
        if (x.type && (clear x.type).first):
            x.type.rest x
            if !(atom x):
                cdr x
                signal: list 'no-way-to-rest x


map1 ← λ(f list):
    if list:
        f (first list) :: map1 f: rest list


fold ← λ(f list start):
    if !list:
        start
        fold f: 
            rest list 
            f (first list) start
 
map ← λ(f ... lists):
    if (and @lists): 
        f @(map1 first lists) :: map f @(map1 rest lists)
        
foreach ← λ('member alist ... 'code):
    map: 
        λ(really member): *code
        alist

while ← λ('test ... 'code):
    if ,test: 
        then:
            map eval code
            while (really test) *code

assign! ← assign

assign ← λ('thing value):
    if (not: atom thing):
        then:
            call ← ,(first thing)
            if call.assign: 
                call.assign *(rest thing) value
                signal: list 'no-known-assignter-for thing
        else:
            leak (really thing)
            assign! (really thing) value

second ← λx: first: rest x

find-if ← λ(f xs):
    if xs:
        if (f: first xs):
            first xs
            find-if: rest xs


class ← λ('name 'inheritance ... 'members):
    leak: really name
    init ← find-if (λx: first x == 'init) members
    init-args ← if init (second init) ()

    it ← really name ← λ(really init-args):
        self ← '(really name)
        it.subclass self
        if init: self.init *(leak-all: init-args)
        self

    it.subclass ← λself:
        map (λ(,class): class.subclass self) inheritance
        map:
            λm: assign self.(really: first m): 
                leak: 
                    self
                    λ(really: second m): *(rest: rest m)
                    self
            members
        self
         

table-assign:
    assign
    info-table table-get
    table-assign


cond ← λ(... 'cases):
    if cases:
        then:
            case ← first cases
            if ,(first case): 
                then: *(rest case)
                else: cond *(rest cases)

unary-- ← λx: 0 - x

or ← λ(test ... 'xs):
    if test:
        test
        or *xs

#-------------------------------------------------------------#
# Playground
